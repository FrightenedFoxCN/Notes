---
comments: True
---

# 拓扑斯的内逻辑

在本节课中我们谈及的拓扑斯都指初等拓扑斯，除非特别指明。

## 拓扑斯的语言

如果你想要研究实数域，你首先需要处理具体的数，例如 $5$，$\frac 2 3$，$\pi$，$\sqrt 2$ 等等。我们将它们称为类型 $\R$ 的常元（constants of type $\R$）：因此，这样的常量的个数与实数的个数相同。但是，你也需要处理类似这样的公式：

$$
a \times (b + c) = (a \times b) + (a \times c)
$$

其中 $a$，$b$，$c$ 表示任意的、未指明的实数。我们称 $a$，$b$，$c$ 为类型 $\R$ 的变元（variables of type $\R$）。因为你能写下的一个公式是一个符号组成的有限序列，你每次只需要有限个（当然，可能非常多个）这样的变量……因此，想要写下所有关于实数的可能公式，一个可列的变量集完全够用。因此，变量的个数与 $\R$ 中元素的个数毫无关系。注意，哪怕你只想讨论单元素集，你也有可能用到两个不同的变量，例如下面的式子表示单元素集只有一个元素：

$$
\forall x\ \forall y\ x = y
$$

一个拓扑斯的语言是你能使用的所有“良定的”（well-formed）符号串的集合：现在的问题就在于，抛却写下的东西的实际含义，怎么界定何为“良定”的符号串。例如，在英语中，你被允许使用字典中的所有单词，并用符合语法规则的方式将它们组合起来，因此 *The prolific fork mixes yellow mathematics.*[^1] 也是一个完全良定的英语句子。

[^1]: “多产的叉子混合黄色的数学。”一个典型的符合语法但是不知所云的句子。——译者注

\definition
    （4.1）考虑拓扑斯 $\mathcal E$，对每个元素 $A \in \mathcal E$ 它的语言给定：

    - 对每个箭头 $1 \to A$，一个符号，称为一个类型 $A$ 的常元。
    - 一个符号组成的可列集，称为类型 $A$ 的变元。

    以及各种由它们组成的形式表达式，叫做项（term）和公式（formula），见下面的定义 4.2 和 4.3。

从现在开始，我们可以直觉地将类型 $A$ 的常元和变元（更广泛的，所有类型 $A$ 的项，如 4.2 所述）视作 $A$ 的形式内元素。我们说这是形式的，是因为直到现在为止，它们只存在于我们的想象当中，它们（尚且）并不与拓扑斯中的任何对象或者箭头相对应。直觉地说，我们希望将拓扑斯的元素视作某种广义的集合。例如，在一个宇性拓扑斯中，层是某种带有“不同水平上”的元素的广义集合。准此原则，如果 $A$ 上面有，比方说，加法 $+: A \times A \to A$，我们当然希望谈论形式内元素 $a + b$，其中 $a$，$b$ 为类型 $A$ 的变元或者常元。如果 $f: A \to B$ 是一个态射，我们希望能够谈论类型 $B$ 的形式内元素 $f(a)$。以此类推。我们希望补充的这些额外的类型 $A$ 或者类型 $B$ 的形式元素被称为类型 $A$ 或者类型 $B$ 的项。定义 4.2 会递归地定义我们在一个拓扑斯中所能考虑的所有可能的项，也就是所有我们能想到的可行的直觉地表示形式内元素的形式表达式。

接下来，假定 $A$ 有一个内在的群结构，因此，加法是结合的，我们自然希望通过“对于所有类型 $A$ 的形式内元素 $a$，$b$，$c$，都有 $(a + b) + c = a + (b + c)$ 成立”来表达这种结合性。这样一个内部元素之间的形式表达式不再是一个形式元素了：它直觉地表达了包含 $a + b$，$b + c$ 等等的项的某种形式上的性质。但是一个公式，直到现在，在拓扑斯中还毫无意义。定义 4.3 会递归地定义我们希望在一个拓扑斯内使用的所有公式。

另外，在公式中，我们还希望使用诸如 $\wedge$，$\vee$，$\implies$，$\exists a$ 或者 $\forall a$ 等等的数学符号。类似于经典逻辑的说法，在 $\exists a$ 或者 $\forall a$ 这样的量词中出现的变元被称为受限变元（bound variable），不在量词中出现的变元被称为自由变元（free variable）。

在定义写下项和公式的定义之前，不妨再次回忆一下，在一个拓扑斯中，类型 $\Omega^A$ 的常元，即形如 $1 \to \Omega^A$ 的态射，与形如 $A \to \Omega$ 的态射之间是有一个双射的，因此，也与 $A$ 的子对象之间有一个双射。这样，$\Omega^A$ 在形式上应当被认为是“A 的子对象的对象”：一个类型 $\Omega^A$ 的常元代表了 $A$ 的一个实际的子对象，一个类型 $\Omega^A$ 的变元可以被认为代表了 $A$ 的一个形式内子对象。

为了避免下面这些定义的核心被一些不必要的关于自由变元的细节掩盖，我们在此省略了这些细节，读者可以参考文献 [4] 的定义 6.1.1，那里有更为精确的定义。

\definition
    （4.2）在拓扑斯 $\mathcal E$ 中，内语言的项被递归地定义如下：

    1. 类型 $A$ 的常元是类型 $A$ 的项；
    2. 类型 $A$ 的变元是类型 $A$ 的项；
    3. 如果 $\tau$ 是类型 $A$ 的项，$f: A \to B$ 是 $\mathcal E$ 中的一个态射，那么 $f(\tau)$ 是一个类型 $B$ 的项；
    4. 如果 $\tau_1, \cdots, \tau_n$ 分别为类型 $A_1, \cdots, A_n$ 的项，那么 $(\tau_1, \cdots, \tau_n)$ 是类型 $A_1 \times \cdots \times A_n$ 的项；
    5. 如果 $\phi$ 是一个带有自由变元 $a_1, \cdots, a_n, b_1, \cdots, b_m$ 的公式，类型分别为 $A_1, \cdots, A_n, B_1, \cdots, B_m$，则 $\{(a_1, \cdots, a_n) | \varphi(a_1, \cdots, a_n, b_1, \cdots, b_m)\}$ 是一个类型 $\Omega^{A_1 \times \cdots \times A_n}$ 的项。

\definition
    （4.3）在拓扑斯 $\mathcal E$ 中，内语言的公式被递归地定义如下：

    1. 符号 $\mathsf{true}$ 和 $\mathsf{false}$ 是公式；
    2. 如果 $\tau$ 和 $\sigma$ 都是类型 $A$ 的项，那么 $\tau = \sigma$ 是一个公式；
    3. 如果 $\tau$ 是一个类型 $A$ 的项，$\Sigma$ 是一个类型 $\Omega^A$ 的项，那么 $\tau \in Sigma$ 是一个公式；
    4. 如果 $\varphi$ 是一个公式，那么 $\lnot \varphi$ 也是一个公式；
    5. 如果 $\varphi$ 和 $\psi$ 都是公式，那么 $\varphi \wedge \psi$，$\varphi \vee \psi$ 和 $\varphi \implies \psi$ 都是公式；
    6. 如果 $\varphi$ 是一个带有自由变元 $a, b_1, \cdots, b_n$ 的公式，它们类型分别是 $A, B_1, \cdots, B_n$，则 $\exists a \varphi(a, b_1, \cdots, b_n)$ 和 $\forall a \varphi(a, b_1, \cdots, b_n)$ 都是带有自由变元 $b_1, \cdots b_n$ 的公式。
    7. 如果 $\varphi$ 是一个带有自由变元 $a_1, \cdots, a_n$ 的公式，类型分别为 $A_1, \cdots, A_n$，$\sigma_1, \cdots, \sigma_n$ 是类型分别为 $A_1, \cdots, A_n$ 的项，带有同为 $b_1, \cdots, b_m$，类型分别为 $B_1, \cdots, B_m$ 的自由变元，则 $\varphi(\sigma_1(b_1, \cdots, b_m), \cdots, \sigma_n(b_1, \cdots, b_m))$ 是一个带有自由变元 $b_1, \cdots, b_m$ 的公式。

注意，上面对于两个公式或者项具备相同自由变量的假设并不是什么真正意义上的限制，因为把某个给定变量当成一个公式或者项的自由变量并不会造成什么问题……哪怕它没有在那个公式或者项中显式出现。

当然，一如既往地，$\exists !x\ \varphi(x)$ 是下面的表达式的缩写：

$$
(\exists x \ \varphi(x)) \wedge ((\varphi(y) \wedge \varphi(z)) \implies (y = z))
$$

换句话说，这一小节旨在表明，拓扑斯的语言事实上正是模仿了集合论的通常语言。但是直到现在为止，这只是一种填字游戏，你通过将一些形式符号并置在一起来构造句子（公式或者项）。但是只有那些在定义 4.2 和 4.3 中所述的“字典”和“语法”中的句子才是良定的，因此，诸如：

$$
\exists a \ \forall b \ (\lnot(a = a)) \wedge (a = b)
$$

是我们语言中的一个完美（但愚蠢的）良定的句子……